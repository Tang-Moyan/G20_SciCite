from _collections_abc import Iterator, Iterable
from structure.document_posting import DocumentPosting


class PostingList(Iterable):
    """
    A list of document IDs and their term frequencies as a posting list.
    Document IDs should be added in ascending order, but can be added in any order and sorted later.

    If the posting list is not sorted, it is possible that there may be duplicate postings.

    To start iterating through the posting list, call the native `iter()` function on this object
    first and store the returned object. Then apply the native `next()` function on the returned
    object to move sequentially through the posting list, or use the `.skip()` function to utilise
    the skip pointers.

    Before skipping, ensure that the current posting has a skip pointer using the `.has_skip()`
    function, otherwise an error will be thrown during a `.skip()` invoke on a posting that has
    no skip pointer.

    Use `PostingList.iter` to create an iterator for this posting list.
    and `PostingListIterator.next` to iterate sequentially through the produced iterator.

    The posting list can be written to disk using `pickle.dump` but should be converted into
    a SerializablePostingList first to avoid recursion limits.

    Supported native operations: `next(), iter(), len(), str(), ==`
    """

    def __init__(self, document_postings=None):
        """
        Creates a new posting list, in the form of a skip list.

        Construction using a list of elements will guarantee that the posting list
        is sorted and distinct.

        Construction requires each element to be in the form of (document ID, frequency).

        :param list[DocumentPosting] document_postings: the sequence of elements
         to construct the posting list from. The document posting consists of the document ID
         and the positional indices of the term in the document.
        """
        self._length = 0
        self._is_sorted = True
        self._head: PostingList._Node | None = None
        self._tail: PostingList._Node | None = None

        self._skip_intervals: list[int] | None = None
        # cached from .add_skip_pointers for serialization purposes, this will be sent to
        # the SerializablePostingList and serialized to file. During deserialization,
        # the skip list is regenerated by passing this list into .add_skip_pointers(intervals)

        if document_postings:
            document_postings = sorted(document_postings, key=lambda x: x.get_document_id())
            self._head = PostingList._Node(document_postings[0])
            self._tail = self._head

            self._length = 1

            for i in range(1, len(document_postings)):
                # if the document ID is the same as the previous document ID, then
                # the increase the frequency of the previous document ID
                if document_postings[i].get_document_id() == self._tail.get_posting().get_document_id():
                    self._tail.get_posting().merge(document_postings[i])
                    continue

                self._tail.get_posting().sort()

                self._tail.next = PostingList._Node(document_postings[i])
                self._length += 1
                self._tail = self._tail.next

    @classmethod
    def deserialize(cls, serializable_posting_list):
        """
        Creates a PostingList from a SerializablePostingList by deserializing the
        SerializablePostingList.

        This is equivalent to calling the .to_posting_list() method on the SerializablePostingList.

        :param SerializablePostingList serializable_posting_list: the serializable posting list
        :return: the deserialized posting list
        :rtype: PostingList
        """
        if not isinstance(serializable_posting_list, PostingList.SerializablePostingList):
            raise TypeError("Expected a SerializablePostingList")

        return serializable_posting_list.to_posting_list()

    class _Node:
        """
        A Node is a container for data within a posting list. Nodes are chained via the `next`
        pointer, but can be skipped across nodes using the `skip` pointer.
        """
        def __init__(self, data):
            """
            Creates a new node of the posting list

            The data is a tuple of the document ID of the document that contains the term
            and the frequency of the term in the document.

            :param DocumentPosting data: the data of the node
            """
            self._data = data
            self.next: PostingList._Node | None = None
            self.skip: PostingList._Node | None = None

        def get_posting(self):
            """

            :return: the data of the node
            :rtype: DocumentPosting
            """
            return self._data

    class PostingListIterator(Iterator):
        """
        An iterator for the posting list that iterates through the elements sequentially,
        or provides an option to skip if available
        """
        def __init__(self, posting_list):
            """
            Creates an iterator that iterates through the posting list

            Use next to move to the next item in the list
            ```
            posting_list_iterator = iter(postingList)
            next_document_id = next(posting_list_iterator)
            ```
            :param PostingList posting_list:
            """
            self._has_begun = False
            self._head = posting_list._head
            self._current = posting_list._head

        def __iter__(self):
            """

            :rtype: PostingList.PostingListIterator
            """
            self._has_begun = False
            self._current = self._head
            return self

        def __next__(self):
            if self.is_exhausted():
                raise StopIteration

            if not self._has_begun:
                self._has_begun = True
                return self._current.get_posting()

            self._current = self._current.next
            return self._current.get_posting()

        def has_skip(self):
            return self._current.skip is not None

        def skip(self):
            if not self.has_skip():
                raise PostingList.NoSkipPointerError("There was no skip pointer on this node.")

            self._current = self._current.skip

            return self._current.get_posting()

        def peek_skip(self):
            """

            :return: the skip element of this current element, without advancing the pointer
            :rtype: DocumentPosting
            """
            if not self.has_skip():
                raise PostingList.NoSkipPointerError("There was no skip pointer on this node.")

            return self._current.skip.get_posting()

        def is_exhausted(self):
            """

            :return: whether the iterator has reached the end of the list
            """
            return not self._current or (self._has_begun and not self._current.next)

    class SerializablePostingList:
        """
        This class is used only to write to disk during pickling.
        It should be loaded to a PostingList after deserialization, before use.
        This is useful when the linked list is very long and pickling
        normally may result in a RuntimeError: maximum recursion depth exceeded.

        The linked list will be traversed through and recorded as a normal sequence
        with no pointers. Its sequential ordering defines the next pointers.
        Skip pointers are defined by a separate list that is cached from the last run
        of `.add_skip_pointer(intervals)`.
        """

        def __init__(self, posting_list):
            """
            Creates a new serializable class
            :param PostingList posting_list: the posting list to serialize
            """
            self._flat_elements = list(iter(posting_list))
            self._skip_intervals = posting_list._skip_intervals

        def to_posting_list(self):
            """
            Converts the serializable posting list back into a usable posting list.

            Used after deserialization.

            :return: a usable posting list from the saved data
            :rtype: PostingList
            """
            postings = PostingList(self._flat_elements)
            postings.add_skip_pointers(self._skip_intervals)

            return postings

        def __len__(self):
            return len(self._flat_elements)

    class NoSkipPointerError(Exception):
        """
        Raised when no skip pointer is present, yet a skip was requested.
        """
        def __init__(self, message=""):
            super().__init__(message)

    class NotSortedError(Exception):
        """
        Raised when the user tried to create an iterable from a posting list, but
        the posting list has not asserted its order yet.
        """
        def __init__(self, message=""):
            super().__init__(message)

    def __len__(self):
        if not self._is_sorted:
            raise PostingList.NotSortedError(
                f"The posting must be sorted before getting the length.")
        return self._length

    def __iter__(self):
        """

        :rtype: PostingList.PostingListIterator
        """
        if not self._is_sorted:
            raise PostingList.NotSortedError(
                f"The posting must be sorted before iteration.")

        return self.PostingListIterator(self)

    def to_iterator(self):
        """
        Functionally equivalent to iter(), but includes type checking to ensure that the
        returned iterator is a PostingListIterator.

        :rtype: PostingList.PostingListIterator
        """
        posting_list_iterator = iter(self)

        if not isinstance(posting_list_iterator, PostingList.PostingListIterator):
            raise TypeError("The iterator returned by iter() is not a PostingListIterator")

        return posting_list_iterator

    def __str__(self):
        return " ".join(map(str, self))

    def __repr__(self):
        return str(self)

    def __eq__(self, other):
        if not isinstance(other, PostingList):
            return False

        return [element for element in self] == [element for element in other]

    def to_serializable_posting_list(self):
        """
        Converts the data types of the posting list into a more serializable-friendly form.
        This is useful when the linked list is very long and pickling the PostingList
        normally may result in a RuntimeError: maximum recursion depth exceeded due to the
        chained references.

        :return: a serializable posting list to use `pickle.dump` on
        :rtype: PostingList.SerializablePostingList
        """
        return PostingList.SerializablePostingList(self)

    def insert(self, *document_posting, sort_posting=False):
        """
        Inserts a document ID into this posting list

        :param DocumentPosting document_posting: the document posting to insert
        :param bool sort_posting: determines if this insert operation will result in
            all posting list elements sorted
        :return: None
        """
        for doc_posting in document_posting:
            if self._tail is None:
                self._head = self._tail = self._head = PostingList._Node(doc_posting)
                self._length += 1
            else:
                # if the tail already exists
                if doc_posting.get_document_id() == self._tail.get_posting().get_document_id():
                    # same document ID, merge the postings
                    self._tail.get_posting().merge(doc_posting)
                    continue
                elif doc_posting.get_document_id() < self._tail.get_posting().get_document_id():
                    # if the new posting is less than the tail, then the posting list
                    # is not sorted
                    self._is_sorted = False

                # different document ID, sort the last posting's positional indices,
                # add to the end of the list
                self._tail.get_posting().sort()
                self._tail.next = PostingList._Node(doc_posting)
                self._tail = self._tail.next
                self._length += 1

        self._tail.get_posting().sort()

        if sort_posting:
            self.sort()

    def sort(self):
        """
        Sorts all the postings in this posting list.

        Will not sort if the posting list is already determined to be sorted.

        :return: whether sorting was performed
        :rtype: bool
        """
        if self._is_sorted:
            return False

        elements: list[DocumentPosting] = []
        current_node = self._head
        while current_node is not None:
            elements.append(current_node.get_posting())
            current_node = current_node.next

        if not elements:
            return False

        sorted_elements = sorted(elements, key=lambda x: x.get_document_id())

        # recompute the length of the posting list and assign the new head and tail
        self._head = PostingList._Node(sorted_elements[0])
        self._tail = self._head
        self._length = 1

        for i in range(1, len(sorted_elements)):
            # if next document posting has the same id, combine the positional indices
            if sorted_elements[i].get_document_id() == self._tail.get_posting().get_document_id():
                self._tail.get_posting().merge(sorted_elements[i])
                continue

            self._tail.get_posting().sort()
            self._tail.next = PostingList._Node(sorted_elements[i])
            self._length += 1
            self._tail = self._tail.next

        self._tail.get_posting().sort()
        self._is_sorted = True
        return True

    def add_skip_pointers(self, intervals):
        """
        Adds skip pointers to all the nodes in this posting list.

        :param list[int] | int intervals: Either an integer, which skips through the list
            by even steps, or a list of integers dictating the intervals to skip through
            at each point
        :rtype: None
        """
        if not self._is_sorted:
            raise PostingList.NotSortedError(
                f"The posting must be sorted before iteration.")

        if not intervals:
            return

        if isinstance(intervals, int):
            intervals = [intervals for _ in range(len(self) // intervals)]

        self._skip_intervals = intervals

        attach_node = self._head
        current_node = self._head
        # remove the skip node
        current_node.skip = None
        increment = 0

        for interval in intervals:
            if interval <= 1:
                # ignore skips of interval 1, equivalent to next
                continue

            while increment != interval:
                current_node = current_node.next

                if current_node is None:
                    # done, no more to assign to
                    return

                current_node.skip = None
                increment += 1

            attach_node.skip = current_node
            increment = 0
            attach_node = current_node
